package crypto

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"math/big"
)

/**
See https://asecuritysite.com/encryption/goecdh
*/

var curve = elliptic.P256()

func GenECDHPrivKey() (*ecdsa.PrivateKey, error)  {
	// Todo: Generate ecdh key in the TPM or at least use randomness generated by the TPM
	// Kernel entropy pool could be exhausted in a embedded system causing delay
	privKey, err := ecdsa.GenerateKey(curve, rand.Reader)
	return privKey, err
}

// concat(X, Y)
func ECCPubKeyToBytes(pubKey *ecdsa.PublicKey) []byte {
	var keyBytes []byte
	keyBytes = append(keyBytes, pubKey.X.Bytes() ...)
	keyBytes = append(keyBytes, pubKey.Y.Bytes() ...)
	return keyBytes
}

func BytesToECCPubKey(bytes []byte) *ecdsa.PublicKey {
	x := big.Int{}
	y := big.Int{}

	return &ecdsa.PublicKey{
		Curve: curve,
		X:     x.SetBytes(bytes[0:32]),
		Y:     y.SetBytes(bytes[32:64]),
	}
}

func ComputeSessionKey(receiverPubKey *ecdsa.PublicKey, myPrivKey *ecdsa.PrivateKey, clientRand [32]byte, serverRand [32]byte) []byte {
	sharedKeyX, sharedKeyY := receiverPubKey.Curve.ScalarMult(receiverPubKey.X, receiverPubKey.Y, myPrivKey.D.Bytes())

	var keyMaterial []byte
	keyMaterial = append(sharedKeyX.Bytes(), sharedKeyY.Bytes() ...)
	keyMaterial = append(keyMaterial, clientRand[:] ...)
	keyMaterial = append(keyMaterial, serverRand[:] ...)

	digest := sha256.Sum256(keyMaterial)
	return digest[:]
}
