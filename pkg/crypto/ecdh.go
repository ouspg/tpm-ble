package crypto

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"math/big"
)

/**
See https://asecuritysite.com/encryption/goecdh
*/

var curve = elliptic.P256()

func GenECDHPrivKey() (*ecdsa.PrivateKey, error)  {
	// Todo: Generate ecdh key in the TPM or at least use randomness generated by the TPM
	// Kernel entropy pool could be exhausted in a embedded system causing delay
	privKey, err := ecdsa.GenerateKey(curve, rand.Reader)
	return privKey, err
}

// concat(X, Y)
func ECCPubKeyToBytes(pubKey *ecdsa.PublicKey) []byte {
	var keyBytes []byte
	keyBytes = append(keyBytes, pubKey.X.Bytes() ...)
	keyBytes = append(keyBytes, pubKey.Y.Bytes() ...)
	return keyBytes
}

func BytesToECCPubKey(bytes []byte) *ecdsa.PublicKey {
	x := big.Int{}
	y := big.Int{}

	return &ecdsa.PublicKey{
		Curve: curve,
		X:     x.SetBytes(bytes[0:32]),
		Y:     y.SetBytes(bytes[32:64]),
	}
}

// openssl devs recommend that the digest of the shared key is used,
// probably to prevent exposing any information about the keys
func ComputeSessionKey(receiverPubKey *ecdsa.PublicKey, myPrivKey *ecdsa.PrivateKey) [32]byte {
	sharedKey, _ := receiverPubKey.Curve.ScalarMult(receiverPubKey.X, receiverPubKey.Y, myPrivKey.D.Bytes())
	return sha256.Sum256(sharedKey.Bytes())
}